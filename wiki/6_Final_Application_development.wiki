#summary Development of final application modifying nAN-36 application (LedButtonDemo)
#labels Featured,Phase-Design,Phase-Deploy

https://dl.dropboxusercontent.com/u/43091897/HostedFile/nRF51822_project/work-in-progress_BIG.png

<wiki:toc max_depth="4" />

= Introduction =
Here are described the modifies to nrf51-ble-app-lbs-master code available on [https://github.com/NordicSemiconductor/nrf51-ble-app-lbs GitHub] and described [https://code.google.com/p/nrf51822-bleeh/wiki/4_First_Bluetooth_Low_Energy_application here]. Since the example's code is very similar final application code, some changes were done to the example's application in order start with a fully working code. Main changes are related to deleting unnecessary BLE-GATT characteristics, add useful speed data to transmission task and adapt connection parameters to the desired one.
In detail, main modifies to actuate are:
 # delete the LED characteristic and others minor changes;
 # modify the BUTTON characteristic replacing button status data with custom data. This data will be replaced by actual speed data in step 3.
 # add LPCOMP functionality and measure speed with help of RTC and LFCLK using code of [https://code.google.com/p/nrf51822-bleeh/wiki/2b_Development_of_Comparator_Driver 2b_Development_of_Comparator_Driver] and [https://code.google.com/p/nrf51822-bleeh/wiki/3_Study_and_Development_of_UltraLowPower_Techniques 3_Study_and_Development_of_UltraLowPower_Techniques] wiki pages. Replace custom data sent in step 2 with actual speed data;
 # in order to preserve energy, transmit data only when it's essential;
 # delete all extra functionality minimizing current consumption (tips [https://devzone.nordicsemi.com/question/5186/how-to-minimize-current-consumption-for-ble-application-on-nrf51822/ here]);

The code could be downloaded from GitHub into your PC. Note that in order to work properly, the code must be copied into a specific folder (../nrf51822/Board/pca10001/s110/), otherwise the header files and source files of the libraries will not found. However I copied such files in the project folder, into the "Include" and "Source" folders and I've modify some project's proprieties  to have portability feature. 
To easily access to code, a stand-alone version is available here for download: [https://code.google.com/p/nrf51822-bleeh/source/browse/#svn%2Ftags%2F6_Final_Application_development_BaseCode svn\tags\6_Final_Application_development_BaseCode]
All the mentioned steps are described below.

==1-Deleting of the LED characteristic and other minor changes==
The first simple modify is to change device's name. The file `main.c` at row 44 is modified as follow:
{{{
#define DEVICE_NAME                     "BLE Speed Sensor"                          /**< Name of device. Will be included in the advertising data. */
}}}
Then let's go to delete the led characteristic: it isn't necessary for our purposes. 
Interesting files, as mentioned in the application note are 3:
 # `main.c`
 # `ble_lbs.h`
 # `ble_lbs.c`


The structure is the same as in other SDK examples, with `main.c` implementing application behavior and the separate service files implementing the service and its behavior. All I/O handling is left to the application.


In `main.c`, can be deleted (or commented out) following code lines:
 * 
{{{
    nrf_gpio_cfg_output(LEDBUTTON_LED_PIN_NO);
}}}
 * 
{{{
    static void led_write_handler(ble_lbs_t * p_lbs, uint8_t led_state)
{
    if (led_state)
    {
        nrf_gpio_pin_set(LEDBUTTON_LED_PIN_NO);
    }
    else
    {
        nrf_gpio_pin_clear(LEDBUTTON_LED_PIN_NO);
    }
}
}}}
 * 
{{{
    init.led_write_handler = led_write_handler;
}}}
while in `ble_lbs.c` can be deleted following lines regarding the function for adding the new led characteristic to the existing GATT service:
 * 
{{{
/**@brief Function for adding the LED characteristic.
 *
 */
static uint32_t led_char_add(ble_lbs_t * p_lbs, const ble_lbs_init_t * p_lbs_init)
{
    ble_gatts_char_md_t char_md;
    ble_gatts_attr_t    attr_char_value;
    ble_uuid_t          ble_uuid;
    ble_gatts_attr_md_t attr_md;

    memset(&char_md, 0, sizeof(char_md));
    
    char_md.char_props.read   = 1;
    char_md.char_props.write  = 1;
    char_md.p_char_user_desc  = NULL;
    char_md.p_char_pf         = NULL;
    char_md.p_user_desc_md    = NULL;
    char_md.p_cccd_md         = NULL;
    char_md.p_sccd_md         = NULL;
    
    ble_uuid.type = p_lbs->uuid_type;
    ble_uuid.uuid = LBS_UUID_LED_CHAR;
    
    memset(&attr_md, 0, sizeof(attr_md));

    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attr_md.read_perm);
    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attr_md.write_perm);
    attr_md.vloc       = BLE_GATTS_VLOC_STACK;
    attr_md.rd_auth    = 0;
    attr_md.wr_auth    = 0;
    attr_md.vlen       = 0;
    
    memset(&attr_char_value, 0, sizeof(attr_char_value));

    attr_char_value.p_uuid       = &ble_uuid;
    attr_char_value.p_attr_md    = &attr_md;
    attr_char_value.init_len     = sizeof(uint8_t);
    attr_char_value.init_offs    = 0;
    attr_char_value.max_len      = sizeof(uint8_t);
    attr_char_value.p_value      = NULL;
    
    return sd_ble_gatts_characteristic_add(p_lbs->service_handle, &char_md,
                                               &attr_char_value,
                                               &p_lbs->led_char_handles);
}
}}}
together with following lines that really call the above-mentioned function.
{{{
    err_code = led_char_add(p_lbs, p_lbs_init);
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    }
}}} 
and the following lines that handle the LED writing event:
{{{
/**@brief Function for handling the Write event.
 *
 * @param[in]   p_sss       LED Button Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_write(ble_sss_t * p_sss, ble_evt_t * p_ble_evt)
{
    ble_gatts_evt_write_t * p_evt_write = &p_ble_evt->evt.gatts_evt.params.write;
    
    if ((p_evt_write->handle == p_sss->led_char_handles.value_handle) &&
        (p_evt_write->len == 1) &&
        (p_sss->led_write_handler != NULL))
    {
        p_sss->led_write_handler(p_sss, p_evt_write->data[0]);
    }
}
}}}

and following case of switch-case structure, in the ble_sss_on_ble_evt() function that handle the BLE event that is the point in which the above on_write() function is called:
{{{			
        case BLE_GATTS_EVT_WRITE:
            on_write(p_sss, p_ble_evt);
            break;
}}}

No led-related functions are available to other c modules thus the file `ble_lbs.h` is unchanged. 

==2-modify the BUTTON characteristic replacing button status data with custom data ==

The service of the final application need only one characteristic that reflects the speed sensor data. In actual example, the button characteristic notifies on button state change, but also allows the peer device to read the button state. This is very similar to the behavior of the speed sensor. The button's status will be replaced with actual speed data, so I can base implementation of my custom code on this, following steps below:

 * Find the method called "button_char_add" and rename it to "speed_sensor_char_add".
 * Rename the files `ble_lbs.c` into `ble_sss.c` and `ble_lbs.h` into `ble_sss.h`. The string sss stand for Speed Sensor Service.
 * Find all string containing `lbs` and and replace them with `sss`.

===Replace state data with custom data===
To send some data via Bluetooth Low Energy, a simple modification to button characteristic was done. It consist on adding a new variable (a simple static counter) to example's code. Exactly in `ble_sss.c` file, into `ble_sss_on_button_change()` function.
When handling the button press, the example's application send a notification to the peer device with the new button state. The SoftDevice API method for doing this is called sd_ble_gatts_hvx, and takes a connection handle and a ble_gatts_hvx_params_t structure as parameters. It then manages the process when a value is to be notified. In the ble_gatts_hvx_params_t structure, you set whether you want a notification or  indication, which attribute handle to be notified, the new data, and the new data length. The method will look as follows:

{{{
uint32_t ble_sss_on_button_change(ble_sss_t * p_sss, uint8_t button_state)
{
    ble_gatts_hvx_params_t params;
    //uint16_t len = sizeof(button_state);
    static uint8_t counter_to_send=0;				        //new variable to test custom data sending
    ++counter_to_send;							//increment the counter
    static uint16_t counter_to_send_len=sizeof(counter_to_send);	//lenght of the counter
    
    memset(&params, 0, sizeof(params));
    params.type = BLE_GATT_HVX_NOTIFICATION;	                        //state here if you want notification or indication
    params.handle = p_sss->button_char_handles.value_handle;
    params.p_data = &counter_to_send;					//counter_to_send copied to hvx structure
    params.p_len = &counter_to_send_len;			        //counter_to_send_len copied to hvx structure
    
    return sd_ble_gatts_hvx(p_sss->conn_handle, &params);	        //issue the PDU
}
}}}

Previous code will notify a custom variable to peer device each time the counter has changed its value. The variable is static, thus its lifetime is the same of the entire application's one (in other words the counter has memory and only a board-reset can reset the counter's value). 

=== Why notification must be enabled by peer device? ===

As described in Bluetooth specification, notification and indication mode must be enabled by adding one more attribute: the client characteristic descriptor (CCCD). This characteristic must be set so one to enable notification (two for indication), as described [https://developer.bluetooth.org/gatt/descriptors/Pages/DescriptorViewer.aspx?u=org.bluetooth.descriptor.gatt.client_characteristic_configuration.xml here]. Furthermore, the default value for the Client Characteristic Configuration descriptor is 0x00. Upon connection of non-binded clients, this descriptor is set to the default value.
So it's a client's charge to write 1 to the CCCD value each time the devices start a connection.
The Master Control Panel does not automatically write to CCCDs unless you click the "enable services"-button or manually write e.g. 01-00 to the descriptor. The peer device that is interested in consuming the data would, on the other hand, automatically write to the descriptor to start getting data flowing.
Into Nordic Semiconductor Developer's forum there are some useful information: [https://devzone.nordicsemi.com/question/14340/can-i-enable-notification-in-my-ble-peripheral/]

===Update connection parameters (on start-up) to preserve energy decreasing data frame rate===
On connection start-up, connection parameters are forced by central device so, in Master Control Panel we'll see following string in log tab:

https://dl.dropboxusercontent.com/u/43091897/HostedFile/nRF51822_project/MCP_init_connection_parameters.png

Therefore there must be a feature of the central device application to perform a connection with ad hoc parameter settings.
In peripheral application could be requested some parameter update trough the function [http://developer.nordicsemi.com/nRF51_SDK/doc/7.1.0/s110/html/a01049.html#ga6e9dce98f85415d2fc3c47f8a599f8fd sd_ble_gap_conn_param_update()] but it is up to the central to decide what the parameters should update to.
Otherwise, as in ble_lbs example, a call to [http://developer.nordicsemi.com/nRF51_SDK/doc/7.1.0/s110/html/a01049.html#ga8c6db7d9bc501929c9cc63b4b04fdfbb sd_ble_gap_ppcp_set()] function could be done. It updates some values in the GATT database that can later be read out by the central device after connecting. So, after some seconds, Master Control Panel show the successful of updating task:

https://dl.dropboxusercontent.com/u/43091897/HostedFile/nRF51822_project/MCP_update_connection_parameters.png

Useful information about connection parameters are available here:
 * [https://devzone.nordicsemi.com/question/60/what-is-connection-parameters/]
 * [https://devzone.nordicsemi.com/question/22689/who-set-initial-connection-parameters-on-ble/]
 * [https://devzone.nordicsemi.com/question/12545/update-connection-parameter-programmatically/]

All features described in this step, are showed in following video. See the custom data replacing the prior button-state data, observe the connection parameters are updating after some seconds from starting and note the enable services button needed to set to one the CCCD value: it allow the GATT server (the peripheral that is the speed sensor) to notify and must be set by the client.

<wiki:video url="https://www.youtube.com/watch?v=OZw28PdlXQU"/>

==3-Add LPCOMP functionality and measure speed with help of RTC==
In order to measure bicycle's speed computing delta-time among two pulses, the low power comparator LPCOMP and a low power clock must be enabled. Code in [https://code.google.com/p/nrf51822-bleeh/wiki/2b_Development_of_Comparator_Driver 2b_Development_of_Comparator_Driver] and [https://code.google.com/p/nrf51822-bleeh/wiki/3_Study_and_Development_of_UltraLowPower_Techniques 3_Study_and_Development_of_UltraLowPower_Techniques] wiki pages is used.

However, in order to interact with SoftDevice SW stack, some changes was made. In details two new files were created: `speed_sensor.c` and its header file `speed_sensor.h`.
They contains some new typedefs and functions to handle events and put events into scheduler queue, interrupt handler linked to LPCOMP and some code to compute the speed. In [https://code.google.com/p/nrf51822-bleeh/source/browse/#svn%2Ftags%2F6_Final_Application_development_BaseCode ble-app-lbs] code was used a scheduler to handle events and events queue.

===Events and event scheduler===
The scheduler is used for transferring execution from the interrupt context to the main context.

https://dl.dropboxusercontent.com/u/43091897/HostedFile/nRF51822_project/scheduler_logic.png

To use scheduler some logic must be implemented. it is spitted into two parts:
==== Logic in main context: ====
 * Define an event handler for each type of event expected. To transmit speed data, the event handler placed in `main.c` file is the `speed_event_handler function`:
{{{
void speed_event_handler(uint32_t speed_data)
{
	uint32_t err_code;
	SEGGER_RTT_WriteString(0,"into speed_event_handler() in main.c\n\r");
	err_code= ble_sss_on_speed_change(&m_sss, speed_data);
	
	if (err_code != NRF_SUCCESS &&
                err_code != BLE_ERROR_INVALID_CONN_HANDLE &&
                err_code != NRF_ERROR_INVALID_STATE)
            {
                APP_ERROR_CHECK(err_code);
            }
}
}}}
 * Initialize the scheduler by calling the APP_SCHED_INIT() macro before entering the application main loop.
 * Call app_sched_execute() from the main loop each time the application wakes up because of an event (typically when sd_app_evt_wait() returns).

==== Logic in interrupt context: ====
 * In the interrupt handler, call app_sched_event_put() with the appropriate data and event handler. This will insert an event into the scheduler's queue. The app_sched_execute() function will pull this event and call its handler in the main context.

 
Some useful information on events and scheduler are available in SDK, [here].


Useful links:
 * https://devzone.nordicsemi.com/question/6976/s110-adc-example/
 * https://devzone.nordicsemi.com/question/15153/s110-lpcomp-interrupt-not-working/







==4-Transmit data only when essential==

==5-Delete all extra functionality minimizing current consumption==

TODO: implement tips suggested on wiki page [https://code.google.com/p/nrf51822-bleeh/wiki/Bluetooth_Smart_and_Low_Power_considerations Bluetooth_Smart_and_Low_Power_considerations] of this project.