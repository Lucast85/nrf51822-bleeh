#summary Development of final application modifying nAN-36 application (LedButtonDemo)
#labels Featured,Phase-Design,Phase-Deploy

https://dl.dropboxusercontent.com/u/43091897/HostedFile/nRF51822_project/work-in-progress_BIG.png

<wiki:toc max_depth="4" />

= Introduction =
Here are described the modifies to nrf51-ble-app-lbs-master code available on [https://github.com/NordicSemiconductor/nrf51-ble-app-lbs GitHub] and described [https://code.google.com/p/nrf51822-bleeh/wiki/4_First_Bluetooth_Low_Energy_application here]. Since the example's code is very similar final application code, some changes were done to the example's application in order start with a fully working code. Main changes are related to deleting unnecessary BLE-GATT characteristics, add useful speed data to transmission task and adapt connection parameters to the desired one.
In detail, main modifies to actuate are:
 # delete the LED characteristic and others minor changes;
 # modify the BUTTON characteristic replacing button status data with custom data. This data will be replaced by actual speed data in step 3.
 # add LPCOMP functionality and measure speed with help of RTC and LFCLK using code of [https://code.google.com/p/nrf51822-bleeh/wiki/2b_Development_of_Comparator_Driver 2b_Development_of_Comparator_Driver] and [https://code.google.com/p/nrf51822-bleeh/wiki/3_Study_and_Development_of_UltraLowPower_Techniques 3_Study_and_Development_of_UltraLowPower_Techniques] wiki pages. Replace custom data sent in step 2 with actual speed data;
 # update connection parameters programmatically (related with bicycle's speed) (tips [https://devzone.nordicsemi.com/question/12545/update-connection-parameter-programmatically/?answer=12551#post-id-12551 here]);
 # delete all extra functionality minimizing current consumption (tips [https://devzone.nordicsemi.com/question/5186/how-to-minimize-current-consumption-for-ble-application-on-nrf51822/ here]);

The code could be downloaded from GitHub into your PC. Note that in order to work properly, the code must be copied into a specific folder (../nrf51822/Board/pca10001/s110/), otherwise the header files and source files of the libraries will not found. However I copied such files in the project folder, into the "Include" and "Source" folders and I've modify some project's proprieties  to have portability feature. 
To easily access to code, a stand-alone version is available here for download: [https://code.google.com/p/nrf51822-bleeh/source/browse/#svn%2Ftags%2F6_Final_Application_development_BaseCode svn\tags\6_Final_Application_development_BaseCode]
All the mentioned steps are described below.

==1-Deleting of the LED characteristic and other minor changes==
The first simple modify is to change device's name. The file `main.c` at row 44 is modified as follow:
{{{
#define DEVICE_NAME                     "BLE Speed Sensor"                          /**< Name of device. Will be included in the advertising data. */
}}}
Then let's go to delete the led characteristic: it isn't necessary for our purposes. 
Interesting files, as mentioned in the application note are 3:
 # `main.c`
 # `ble_lbs.h`
 # `ble_lbs.c`


The structure is the same as in other SDK examples, with `main.c` implementing application behavior and the separate service files implementing the service and its behavior. All I/O handling is left to the application.


In `main.c`, can be deleted (or commented out) following code lines:
 * 
{{{
    nrf_gpio_cfg_output(LEDBUTTON_LED_PIN_NO);
}}}
 * 
{{{
    static void led_write_handler(ble_lbs_t * p_lbs, uint8_t led_state)
{
    if (led_state)
    {
        nrf_gpio_pin_set(LEDBUTTON_LED_PIN_NO);
    }
    else
    {
        nrf_gpio_pin_clear(LEDBUTTON_LED_PIN_NO);
    }
}
}}}
 * 
{{{
    init.led_write_handler = led_write_handler;
}}}
while in `ble_lbs.c` can be deleted following lines regarding the function for adding the new led characteristic to the existing GATT service:
 * 
{{{
/**@brief Function for adding the LED characteristic.
 *
 */
static uint32_t led_char_add(ble_lbs_t * p_lbs, const ble_lbs_init_t * p_lbs_init)
{
    ble_gatts_char_md_t char_md;
    ble_gatts_attr_t    attr_char_value;
    ble_uuid_t          ble_uuid;
    ble_gatts_attr_md_t attr_md;

    memset(&char_md, 0, sizeof(char_md));
    
    char_md.char_props.read   = 1;
    char_md.char_props.write  = 1;
    char_md.p_char_user_desc  = NULL;
    char_md.p_char_pf         = NULL;
    char_md.p_user_desc_md    = NULL;
    char_md.p_cccd_md         = NULL;
    char_md.p_sccd_md         = NULL;
    
    ble_uuid.type = p_lbs->uuid_type;
    ble_uuid.uuid = LBS_UUID_LED_CHAR;
    
    memset(&attr_md, 0, sizeof(attr_md));

    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attr_md.read_perm);
    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attr_md.write_perm);
    attr_md.vloc       = BLE_GATTS_VLOC_STACK;
    attr_md.rd_auth    = 0;
    attr_md.wr_auth    = 0;
    attr_md.vlen       = 0;
    
    memset(&attr_char_value, 0, sizeof(attr_char_value));

    attr_char_value.p_uuid       = &ble_uuid;
    attr_char_value.p_attr_md    = &attr_md;
    attr_char_value.init_len     = sizeof(uint8_t);
    attr_char_value.init_offs    = 0;
    attr_char_value.max_len      = sizeof(uint8_t);
    attr_char_value.p_value      = NULL;
    
    return sd_ble_gatts_characteristic_add(p_lbs->service_handle, &char_md,
                                               &attr_char_value,
                                               &p_lbs->led_char_handles);
}
}}}
together with following lines that really call the above-mentioned function.
{{{
    err_code = led_char_add(p_lbs, p_lbs_init);
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    }
}}} 
and the following lines that handle the LED writing event:
{{{
/**@brief Function for handling the Write event.
 *
 * @param[in]   p_sss       LED Button Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_write(ble_sss_t * p_sss, ble_evt_t * p_ble_evt)
{
    ble_gatts_evt_write_t * p_evt_write = &p_ble_evt->evt.gatts_evt.params.write;
    
    if ((p_evt_write->handle == p_sss->led_char_handles.value_handle) &&
        (p_evt_write->len == 1) &&
        (p_sss->led_write_handler != NULL))
    {
        p_sss->led_write_handler(p_sss, p_evt_write->data[0]);
    }
}
}}}

and following case of switch-case structure, in the ble_sss_on_ble_evt() function that handle the BLE event that is the point in which the above on_write() function is called:
{{{			
        case BLE_GATTS_EVT_WRITE:
            on_write(p_sss, p_ble_evt);
            break;
}}}

No led-related functions are available to other c modules thus the file `ble_lbs.h` is unchanged. 

==2-modify the BUTTON characteristic replacing button status data with custom data ==

The service will have only one characteristic that reflects the speed sensor data. The button characteristic notifies on button state change, but also allows the peer device to read the button state. This is very similar to the behavior of the speed sensor. The button's status will be replaced with actual speed data, so I can base my implementation on this, following steps below:

 * Find the method called "button_char_add" and rename it to "speed_sensor_char_add".
 * Rename the files `ble_lbs.c` into `ble_sss.c` and `ble_lbs.h` into `ble_sss.h`. The string sss stand for Speed Sensor Service.
 * Find all string containing `lbs` and and replace them with `sss`.

===Replace state data with custom data===
To send some data via Bluetooth Low Energy, a simple modification to button characteristic was done. It consist on adding a new variable (a simple static counter) to example's code. Exactly in `ble_sss.c` file, into `ble_sss_on_button_change()` module.
When handling the button press, you want to send a notification to the peer device with the new button state. The SoftDevice API method for doing this is called sd_ble_gatts_hvx, and takes a connection handle and a ble_gatts_hvx_params_t structure as parameters. It then manages the process when a value is to be notified. In the ble_gatts_hvx_params_t structure, you set whether you want a notification or  indication, which attribute handle to be notified, the new data, and the new data length. The method will look as follows:

{{{
uint32_t ble_sss_on_button_change(ble_sss_t * p_sss, uint8_t button_state)
{
    ble_gatts_hvx_params_t params;
    //uint16_t len = sizeof(button_state);
    static uint8_t counter_to_send=0;				        //new variable to test custom data sending
    ++counter_to_send;							//increment the counter
    static uint16_t counter_to_send_len=sizeof(counter_to_send);	//lenght of the counter
    
    memset(&params, 0, sizeof(params));
    params.type = BLE_GATT_HVX_NOTIFICATION;	                        //state here if you want notification or indication
    params.handle = p_sss->button_char_handles.value_handle;
    params.p_data = &counter_to_send;					//counter_to_send copied to hvx structure
    params.p_len = &counter_to_send_len;			        //counter_to_send_len copied to hvx structure
    
    return sd_ble_gatts_hvx(p_sss->conn_handle, &params);	        //issue the PDU
}
}}}

Previous code will notify a custom variable to peer device each time the counter has changed its value. The variable is static, thus its lifetime it is the same of the entire application's lifetime (e.g. the counter has memory and only a board-reset can reset the counter's value). 

=== Why notification must be enabled by peer device? ===

As described in Bluetooth specification, notification and indication mode must be enabled by adding one more attribute: the client characteristic descriptor (CCCD). This characteristic must be set so one to enable notification (two for indication), as described [https://developer.bluetooth.org/gatt/descriptors/Pages/DescriptorViewer.aspx?u=org.bluetooth.descriptor.gatt.client_characteristic_configuration.xml here]. Furthermore, the default value for the Client Characteristic Configuration descriptor is 0x00. Upon connection of non-binded clients, this descriptor is set to the default value.
So it's a client's charge to write 1 to the CCCD value each time the devices start a connection.
Into Nordic Semiconductor Developer's space there are some useful information: [https://devzone.nordicsemi.com/question/14340/can-i-enable-notification-in-my-ble-peripheral/]

===Update connection parameters to preserve energy decreasing data frame rate===


All feature described in this step, are showed in following video. See the custom data replacing the prior button-state data, observe the connection parameters are updating after some seconds from starting and note the enable services button needed to set to one the CCCD value: it allow the GATT server (the peripheral that is the speed sensor) to notify and must be set by client.

<wiki:video url="https://www.youtube.com/watch?v=OZw28PdlXQU"/>

==3-Add LPCOMP functionality and measure speed with help of RTC==
Useful link: 
 * https://devzone.nordicsemi.com/question/6976/s110-adc-example/
 * https://devzone.nordicsemi.com/question/15153/s110-lpcomp-interrupt-not-working/

==4-Update connection parameters programmatically==

==5-Delete all extra functionality minimizing current consumption==