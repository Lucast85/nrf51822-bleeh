#summary Development of final application modifying nAN-36 application (LedButtonDemo)
#labels Featured,Phase-Design,Phase-Deploy

https://dl.dropboxusercontent.com/u/43091897/HostedFile/nRF51822_project/work-in-progress_BIG.png

<wiki:toc max_depth="4" />

= Introduction =
Here are described the modifies to nrf51-ble-app-lbs-master code available on [https://github.com/NordicSemiconductor/nrf51-ble-app-lbs GitHub]. And described [https://code.google.com/p/nrf51822-bleeh/wiki/4_First_Bluetooth_Low_Energy_application here].
Mains modifies to actuate are:
 # delete the LED characteristic and others minor changes;
 # modify the BUTTON characteristic replacing button status data with custom data. This data will be replaced by actual speed data in step 3.
 # add LPCOMP functionality and measure speed with help of RTC and LFCLK using code of [https://code.google.com/p/nrf51822-bleeh/wiki/2b_Development_of_Comparator_Driver 2b_Development_of_Comparator_Driver] and [https://code.google.com/p/nrf51822-bleeh/wiki/3_Study_and_Development_of_UltraLowPower_Techniques 3_Study_and_Development_of_UltraLowPower_Techniques] wiki pages. Replace custom data sent in step 2 with actual speed data;
 # update connection parameters programmatically (related with bicycle's speed) (tips [https://devzone.nordicsemi.com/question/12545/update-connection-parameter-programmatically/?answer=12551#post-id-12551 here]);
 # delete all extra functionality minimizing current consumption (tips [https://devzone.nordicsemi.com/question/5186/how-to-minimize-current-consumption-for-ble-application-on-nrf51822/ here]);

The code could be downloaded from GitHub into your PC. Note that in order to work properly, the code must be copied into a specific folder (../nrf51822/Board/pca10001/s110/), otherwise the header files and source files of the libraries will not found. However I copied this files in the project folder, into the "Include" and "Source" folders and I've modify some project's options to have portability feature. 
To easily access to code, a stand-alone version is available here: [https://code.google.com/p/nrf51822-bleeh/source/browse/#svn%2Ftags%2F6_Final_Application_development_BaseCode svn\tags\6_Final_Application_development_BaseCode]

==1 Delete the LED characteristic and other minor changes==
The first simple modify is to change device's name. The file `main.c` at row 44 is modified as follow:
{{{
#define DEVICE_NAME                     "BLE Speed Sensor"                          /**< Name of device. Will be included in the advertising data. */
}}}
Then let's go to delete the led characteristic: it isn't necessary for our purposes. 
Interesting files, as mentioned in the application note are 3:
 # `main.c`
 # `ble_lbs.h`
 # `ble_lbs.c`
The structure is the same as in other SDK examples, with `main.c` implementing application behavior and the separate service files implementing the service and its behavior. All I/O handling is left to the application.

In `main.c`, can be deleted (or commented out) following code lines:
 * 
{{{
    nrf_gpio_cfg_output(LEDBUTTON_LED_PIN_NO);
}}}
 * 
{{{
    static void led_write_handler(ble_lbs_t * p_lbs, uint8_t led_state)
{
    if (led_state)
    {
        nrf_gpio_pin_set(LEDBUTTON_LED_PIN_NO);
    }
    else
    {
        nrf_gpio_pin_clear(LEDBUTTON_LED_PIN_NO);
    }
}
}}}
 * 
{{{
    init.led_write_handler = led_write_handler;
}}}
while in `ble_lbs.c` can be deleted following lines regarding the function for adding the new led characteristic to the existing GATT service:
 * 
{{{
/**@brief Function for adding the LED characteristic.
 *
 */
static uint32_t led_char_add(ble_lbs_t * p_lbs, const ble_lbs_init_t * p_lbs_init)
{
    ble_gatts_char_md_t char_md;
    ble_gatts_attr_t    attr_char_value;
    ble_uuid_t          ble_uuid;
    ble_gatts_attr_md_t attr_md;

    memset(&char_md, 0, sizeof(char_md));
    
    char_md.char_props.read   = 1;
    char_md.char_props.write  = 1;
    char_md.p_char_user_desc  = NULL;
    char_md.p_char_pf         = NULL;
    char_md.p_user_desc_md    = NULL;
    char_md.p_cccd_md         = NULL;
    char_md.p_sccd_md         = NULL;
    
    ble_uuid.type = p_lbs->uuid_type;
    ble_uuid.uuid = LBS_UUID_LED_CHAR;
    
    memset(&attr_md, 0, sizeof(attr_md));

    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attr_md.read_perm);
    BLE_GAP_CONN_SEC_MODE_SET_OPEN(&attr_md.write_perm);
    attr_md.vloc       = BLE_GATTS_VLOC_STACK;
    attr_md.rd_auth    = 0;
    attr_md.wr_auth    = 0;
    attr_md.vlen       = 0;
    
    memset(&attr_char_value, 0, sizeof(attr_char_value));

    attr_char_value.p_uuid       = &ble_uuid;
    attr_char_value.p_attr_md    = &attr_md;
    attr_char_value.init_len     = sizeof(uint8_t);
    attr_char_value.init_offs    = 0;
    attr_char_value.max_len      = sizeof(uint8_t);
    attr_char_value.p_value      = NULL;
    
    return sd_ble_gatts_characteristic_add(p_lbs->service_handle, &char_md,
                                               &attr_char_value,
                                               &p_lbs->led_char_handles);
}
}}}
together with following lines that really call the above-mentioned function.
{{{
    err_code = led_char_add(p_lbs, p_lbs_init);
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    }
}}} 
and the following lines that handle the LED writing event:
{{{
/**@brief Function for handling the Write event.
 *
 * @param[in]   p_sss       LED Button Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_write(ble_sss_t * p_sss, ble_evt_t * p_ble_evt)
{
    ble_gatts_evt_write_t * p_evt_write = &p_ble_evt->evt.gatts_evt.params.write;
    
    if ((p_evt_write->handle == p_sss->led_char_handles.value_handle) &&
        (p_evt_write->len == 1) &&
        (p_sss->led_write_handler != NULL))
    {
        p_sss->led_write_handler(p_sss, p_evt_write->data[0]);
    }
}
}}}

and following case of switch-case structure, in the ble_sss_on_ble_evt() function that handle the BLE event that is the point in which the above on_write() function is called:
{{{			
        case BLE_GATTS_EVT_WRITE:
            on_write(p_sss, p_ble_evt);
            break;
}}}

No led-related functions are available to other c modules thus the file `ble_lbs.h` is unchanged. 
This step is done and related code is here: [https://code.google.com/p/nrf51822-bleeh/source/browse/#svn%2Ftags%2F6_1_Final_Application_development_step_1 svn\tags\6_1_Final_Application_development_step_1]

==2 modify the BUTTON characteristic replacing button status data with custom data ==

The service will have only one characteristic that reflects the speed sensor data. The button characteristic notifies on button state change, but also allows the peer device to read the button state. This is very similar to the behavior of the speed sensor. The button's status will be replaced with actual speed data, so I can base my implementation on this, following steps below:

 * Find the method called "button_char_add" and rename it to "speed_sensor_char_add".
 * Rename the files `ble_lbs.c` into `ble_sss.c` and `ble_lbs.h` into `ble_sss.h`. The string sss stand for Speed Sensor Service.
 * Find all string containing `lbs` and and replace them with `sss`.

===Replace state data with custom data===
To send some data via Bluetooth Low Energy, a simple modification to button characteristic was done. It consist on adding a new variable (a simple static counter) to example's code. Exactly in `ble_sss.c` file, into `ble_sss_on_button_change()` module.
When handling the button press, you want to send a notification to the peer device with the new button state. The SoftDevice API method for doing this is called sd_ble_gatts_hvx, and takes a connection handle and a ble_gatts_hvx_params_t structure as parameters. It then manages the process when a value is to be notified. In the ble_gatts_hvx_params_t structure, you set whether you want a notification or  indication, which attribute handle to be notified, the new data, and the new data length. The method will look as follows:

{{{
uint32_t ble_sss_on_button_change(ble_sss_t * p_sss, uint8_t button_state)
{
    ble_gatts_hvx_params_t params;
    //uint16_t len = sizeof(button_state);
		static uint8_t counter_to_send=0;					//new variable to test custom data sending
		++counter_to_send;												//increment the counter
		static uint16_t counter_to_send_len=sizeof(counter_to_send);	//lenght of the counter
    
    memset(&params, 0, sizeof(params));
    params.type = BLE_GATT_HVX_NOTIFICATION;	//state here if you want notification or indication
    params.handle = p_sss->button_char_handles.value_handle;
    params.p_data = &counter_to_send;					//counter_to_send copied to hvx structure
    params.p_len = &counter_to_send_len;			//counter_to_send_len copied to hvx structure
    
    return sd_ble_gatts_hvx(p_sss->conn_handle, &params);	//issue the PDU
}
}}}

The button_char_add method expects to find a parameter stating whether or not notifications are supported, but in this case only notification support is wanted.

=== Why notification must be enabled by peer device? ===

https://devzone.nordicsemi.com/question/14340/can-i-enable-notification-in-my-ble-peripheral/


===Update connection parameters to preserve energy decreasing data frame rate===

==3-Add LPCOMP functionality and measure speed with help of RTC==
Useful link: 
 * https://devzone.nordicsemi.com/question/6976/s110-adc-example/
 * https://devzone.nordicsemi.com/question/15153/s110-lpcomp-interrupt-not-working/